<html layout:decorate="~{layouts/main_staff}">
    <head>
        <script th:inline="javascript">
            const jsonMap = [[${jsonFormatMap}]];
        </script>
        <script src="https://d3js.org/d3.v7.min.js"></script>
        <style>
        	#space-overview-card-body {
        		display: block !important;
        		padding: 1.25rem !important;
        		text-align: center;
        	}
        </style>
    </head>
    <body>
        <div layout:fragment="content">
        <div class="container">
            <div id="graph" style="width: 100%;height: 100%; background-color: #909090"></div>
            <div class="card" style="width: 18rem;">
			  <img src="/vspace/resources/maintenance/img/logo-11.png" class="card-img-top" id="space-overview-card-img" alt="...">
			  <div class="card-body" id="space-overview-card-body">
			    <h5 class="card-title" id="space-overview-card-title">Space Overview Map</h5>
			    <p class="card-text" id="space-overview-card-text">This is a map of all spaces and modules and their links with one another. Feel free to click or drag nodes to interact with them.</p>
			    <a href="#" class="btn btn-primary" id="space-overview-btn">Click a space or module node...</a>
			  </div>
			</div>
            <script>
                var nodeJson = JSON.parse(jsonMap['nodesJson']);                
                const width = 928;
                const height = 600;

                const nodeArrays = categorizeNodes(nodeJson);
                const root = structureData(nodeArrays);            	
                const spaceLinks = getSpaceLinks(root.children);
                const links = root.links();
                spaceLinks.forEach(function (link) {
                	links.push(link);
                });
                const nodes = root.descendants();
                
                const simulation = d3.forceSimulation(nodes)
	                .force("link", d3.forceLink(links).id(d => d.data.id).distance(100).strength(1))
	                .force("charge", d3.forceManyBody().strength(-500))
	                .force("x", d3.forceX())
	                .force("y", d3.forceY());
                
                const svg = d3.select("#graph").append("svg")
                    .attr("width", width)
                    .attr("height", height)
                    .attr("viewBox", [-width / 2, -height / 2, width, height])
      				.attr("style", "max-width: 100%; height: auto;");                    
                
                const link = svg.append("g")
                    .attr("stroke", "white")
                    .attr("stroke-opacity", 0.6)
                  .selectAll("line")
                  .data(links)
                  .join("line");
                
                drag = simulation => {
  	          	  
  	          	  function dragstarted(event, d) {
  	          	    if (!event.active) simulation.alphaTarget(0.3).restart();
  	          	    d.fx = d.x;
  	          	    d.fy = d.y;
  	          	  }
  	          	  
  	          	  function dragged(event, d) {
  	          	    d.fx = event.x;
  	          	    d.fy = event.y;
  	          	  }
  	          	  
  	          	  function dragended(event, d) {
  	          	    if (!event.active) simulation.alphaTarget(0);
  	          	    d.fx = null;
  	          	    d.fy = null;
  	          	  }
  	          	  
  	          	  return d3.drag()
  	          	      .on("start", dragstarted)
  	          	      .on("drag", dragged)
  	          	      .on("end", dragended);
  	         	}
                
                const node = svg.append("g")
				    .attr("stroke-width", 1.5)
                  .selectAll("circle")
			      .data(nodes)
			      .join("circle")
				    .call(drag(simulation))
	             		
           	    const text = svg.append("g")
                  .selectAll("text")
                  .data(nodes)
                  .enter().append("text")
                  .text(d => d.data.name)
                  .attr("x", d => d.x)
                  .attr("y", d => d.y)
                  .attr("text-anchor", "middle")
                  .style("font-size", "12px")
                  .style("font-weight", 900);
           	    
	           	// Hide root node
	           	node.style("opacity", function(d) { return d.depth === 0 ? 0 : 1; })
	           		.style("pointer-events", function(d) { return d.depth === 0 ? "none" : "all"; })
	           	// Make module nodes smaller
	           		.style("r", function(d) { return d.depth === 2 ? 18 : d.depth === 1 ? 27 : 0; })
	           		.style("fill", function(d) { return d.depth === 1 ? "#fff" : "#000"; })
	           		
		           	.on("mouseover", function(event, d) {
					    d3.select(this)
					      .style("cursor", "pointer");
					})
					.on("mouseout", function(event, d) {
					    d3.select(this)
					      .style("cursor", "default");
					})
	            	.on('click', function(event, d) {
	            		//Reset highlighting
	            		d3.selectAll("circle")
							.style("fill", function(d) { return d.depth === 1 ? "#fff" : "#000"; });
	            		
	            		//Update card for node clicked
	            		if (d.data.img) {
		            		document.getElementById("space-overview-card-img").src = d.data.img;
	            		} else {
	            			document.getElementById("space-overview-card-img").src = "/vspace/resources/maintenance/img/logo-11.png";
	            		}
	           			if (d.data.link) {
	           				document.getElementById("space-overview-btn").href = d.data.link;
	            		} else {
	            			alert("The selected node has no link.");
	            		}
	           			document.getElementById("space-overview-btn").innerHTML = "Go to " + d.data.name;
	           			document.getElementById("space-overview-card-title").innerHTML = d.data.name;
	           			document.getElementById("space-overview-card-text").innerHTML = d.data.description;
	           			d3.selectAll("circle").filter(function(n) {
	                    	return n.data.id == d.data.id;
	                  	}).style("fill", "red");
	            	});
	           	
	           	text.style("fill", function(d) { console.log('DEPTH: ', d.depth); return d.depth === 1 ? "#000" : "#fff"; });
	           	
           	 	d3.selectAll("line").filter(function(d) {
                	return d.source.depth === 0;
              	}).style("visibility", "hidden")
              	  .style("opacity", 0)
           	 	  .style("pointer-events", "none");
           	 	  
	            simulation.on("tick", () => {
	              link
	                  .attr("x1", d => d.source.x)
	                  .attr("y1", d => d.source.y)
	                  .attr("x2", d => d.target.x)
	                  .attr("y2", d => d.target.y);
	
	              node
	                  .attr("cx", d => d.x)
	                  .attr("cy", d => d.y);
	              
	              text
		              .attr("x", d => d.x)
		              .attr("y", d => d.y);
	            });
             
                function structureData(nodeArrays) {
                	var map = {};
                	map.children = [];

                	function createHierarchy(spaces, modules) {
                		spaces.forEach(function (space) {
                			if (space.edges.length > 0) {
                				space.edges.forEach(function (edge) {
                    				childModule = modules.find(item => item.id === edge);
                    				if (childModule) {
                    					space.children.push(childModule);
                    				}
                    			});	
                			}
                			map.children.push(space);
                		});
                	}
                	                	
                	createHierarchy(nodeArrays.spaces, nodeArrays.modules);         	
                	return d3.hierarchy(map);
                }
                
                function categorizeNodes(nodes) {
            		spaces = [];
            		modules = [];
            		nodes.forEach(function (node) {
                		if (!node.module) {
                			// Only spaces have children
                			node.children = [];
                			spaces.push(node);
                		} else {
                			modules.push(node);
                		}
                	});
            		return {"spaces": spaces, "modules": modules};
            	}
                
                // Links between spaces need to be created manually because tree hierarchy only generates links with children
                function getSpaceLinks(spaces) {
                	spaceLinkList = [];
                	spaces.forEach(function (space) {
            			if (space.data.edges.length > 0) {
            				space.data.edges.forEach(function (edge) {
                				spaceTarget = spaces.find(item => item.data.id === edge);
                				if (spaceTarget) {
                					spaceLinkList.push({
                						source: space,
                						target: spaceTarget
                					});
                				}
                			});	
            			}
            		});
                	return spaceLinkList;
                }
            </script>
        </div>
        </div>
    </body>
</html>